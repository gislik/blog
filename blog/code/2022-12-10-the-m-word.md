---
title: The M-word
tags: haskell
image: /img/2021/mushroom.png
summary: |
  
---

Much of our technological progress has gone hand in hand with our ability to create abstractions for complex ideas. Abstractions allow us to think in general terms and therefore reuse methods and processes for different concrete instances of the abstraction. An operating system is an abstraction which generalizes our interaction with different kinds of computer hardware. Programming languages allow developers to write human-readable code and later compile the code to assembly language[^assembly] and finally to its binary form for the computer to run.

> Monads are an abstraction that can be used to handle exceptions, state management, asynchronous code execution, concurrency, logging, control flow, and more, without any special language support.

By studying the history of programming languages, we can see that each programming language paradigm has introduced a new set of abstractions, which allow the developer to express their computations at a higher and higher level.

<!-- ## Monads are everywhere but you can’t see them -->

[Haskell](/tags/haskell) is a purely functional programming language and has therefore no access to the I/O of the computer[^pure]. Programs executing without I/O can neither read input from the keyboard nor write output to the screen, let alone performing more complex actions like using a network connection[^useless]. Monads were introduced as the solution which allowed Haskell programs to isolate I/O actions in containers, which could be passed as arguments or returned from pure functions[^monad]. 

In addition to solving the I/O problem Haskell faced, monads turned out to be a powerful abstraction which, allows developers to overload the semi-colon in their code[^overload]. That ability can be used to handle exceptions, state management, asynchronous code execution, concurrency, logging, control flow, and more, without any special language support. 

# Error handling

In a low level language, like C, all errors must be handled explicitly by comparing the return value against known error values. When the return value is reserved for error codes, all other return values must be passed as pointer arguments to the function. That is both counter-intuitive from the point of the caller and can result in a memory corruption if the function doesn't handle the pointer correctly. It is also easy to make a mistake when comparing the error code to known error values, e.g. does `-1` indicate an error or is it `0`? 

Newer languages like Go hide this complexity a bit and allow you to return two variables from the function call, the first one is the real return value and the second is either an error or `nil` on success. Checking the return value for errors on every function call is a simple but not a very ergonomic approach and functions don’t compose naturally.


Other programming languages, like JavaScript and TypeScript, allow the developer to throw exceptions when errors occur and catch them higher in the call stack.

~~~js
import { openSync, readFileSync } from 'node:fs';

function isEmptyBuffer(buffer) {
   return buffer.size == 0;
}

let isEmpty;

try {
   const fd = openSync("/etc/passwd", "r");
   const buf = readFileSync(fd);
   isEmpty = isEmptyBuffer(buf)
} catch (err) {
   // it's hard to differentiate between error types in javascript
}
~~~

The downside of throwing exceptions is that not all programming languages support that mechanism, it can be hard to know what kind of exceptions you should expect, especially if there are multiple function calls which may throw exceptions, and if errors aren't caught by the direct caller of a throwing functions, the control flow may be returned to an arbitrary place on the call stack.

From these examples it becomes apparent that error handling can be daunting. It is hard to know which functions can fail and which are deterministic, and either we have to check for error conditions on all functions which can fail or we risk getting an unexpected control flow if we’re not careful. 

What kind of code would we like to write? Let’s imagine that all impure functions return their values wrapped in a `Result<T>`.

~~~js
class Result<T, E> {
   value: T | undefined;
   error: E | undefined;
   
   constructor(v: T) {
      value = v;
   } 
   constructor(e: E) {
      error = e;
   }

   andThen(action: (T) => Result<U, E>): Result<U, E> {
      if (this.error != undefined) {
         return this;
      }
      return action(this.value);
   }   
   
   map(f: (T) => U): Result<U, E> {
      if (this.error != undefined) {
         return this;
      }
      return new Result(f(this.value));
   }
}
~~~

This would allow us to write the program in this manner.

~~~js
const result = 
   open("/etc/passwd")
      .andThen(readFile)
      .map(isEmptyBuffer);
   
if (!result.ok) {
   // error occurred
}
const isEmpty = result.value;
~~~

The function calls are nicely chained with the file descriptor returned from `open` passed as the first argument to `readFile` and in case any of the function calls fails the computation stops. Since the function `isEmptyBuffer` is mapped over the returned from the function chain, it is obviously a pure function and cannot return an error. In this example the chaining of the function calls worked well because `readFile` only has 1 required argument. In case we want to take the return value of two separate functions and use them as the input parameters later, chaining becomes unwieldy.

~~~js
const result = 
   open("/etc/passwd")
      .andThen((fd) => 
         getOptions().
            andThen((opts) => readFile(fd, opts))
      )
      .map(isEmptyBuffer);
   
if (!result.ok) {
   // error occurred
}
const isEmpty = result.value;
~~~

How about we introduce some syntax sugar, which would take the below code and de-sugar it into the code above?

~~~js
let result = result () => {
   const fd = open("/etc/passwd")?
   const opts = getOptions()?
   const buf = readFile(fd, opts)?
   return isEmptyBuffer(buf);
}();
		
if (!result.ok) {
   // error occurred
}
const isEmpty = result.value;
~~~

A few things to note:

1. The keyword `result` in the function signature indicates that the function returns a value of type Result<T, E>, similar to how `async` can be used in a function signature to indicate that the function has asynchronous code paths.
2. There is no question mark at at the end of `return isEmptyBuffer(buf);` since `isEmptyBuffer` is a pure function.
3. This version is remarkably close to the original version where exceptions were thrown and caught. It is easy to imagine that when we annotate the function with `result`, that we are essentially overloading the semi-colons in the original version, which allows us to inject code between the lines, which either unwraps the `value: T` from each expression `Result<T, E>` or in case of an error, returns the whole the error early from the function wrapped in a `Result<T, E>`, which short-circuits all the remaining statements in the function body.
4. `Result<T, E>` is a monad.

# Instrumenting

~~~js
class Instrument<T> {
   value: T;
   totalDuration: number;
   
   constructor(v: T) {
      this.value = v;
   }
   
   andThen(action: (T) => Instrument<U>): Instrument<U> {
      const start = new Date().getTime();
      let retval = action(this.value);
      const duration = new Date().getTime() - start;
      retval.totalDuration = this.totalDuration + duration;
      return retval
   }
   
   map(f: (T) => U): Instrument<U> {
      const start = new Date().getTime();
      let reval = f(this.value)
      duration = new Date().getTime() - start;
      this.totalDuration += duration;
      return this;
   }
}
~~~

~~~js
interface Monad<T> {
   andThen<U>(action: T => Monad<U>): Monad<U>;
   map<U>(f: (T) => U): Monad<U>;
}
   
open(filename: string): Monad<number>
read(fd: number): Monad<buffer>
~~~

~~~js
let result = instrument () => {
   const fd = open("/etc/passwd")?
   const opts = getOptions()?
   const buf = readFile(fd, opts)?
   return isEmptyBuffer(buf);
}();

console.log(`This computation returned ${result.value} and took ${result.totalDuration}`);
~~~

Although few programming languages have introduced monads directly, many newer languages either have them conceptually but call them something else or have language features which are heavily inspired by them. 

[^pure]: Pure functions are deterministic which means that, given an input, they will always return the same result. Impure functions may perform some side effects which may cause the function to return a different result on different invocations. A function which when called, returns the current time is an example of an impure function with side-effects. 

[^assembly]: Assembly language is another form abstraction. In this way abstractions can be recursively built on top of abstractions.

[^overload]: Many language allow operator overloading…

[^monad]: Monads originate from category theory…

[^useless]: In reality, the original version of Haskell granted programs access I/O, by using an external wrapper program which received a list of pure requests for I/O actions from the Haskell program, then performed the impure actions before returning a list of pure results back to the Haskell program. 

[Monads are just monoids in the category of endofunctors](https://blog.merovius.de/posts/2018-01-08-monads-are-just-monoids/)
[Monads for functional programming](https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf)



<!--
~~~haskell
main: [Response] -> [Request]
~~~

~~~haskell
type IO a = World -> (a, World)
~~~


I’ve seen hundreds of tutorials and videos on monads

The relationship between mathematics and programming

2 videos on Monads

~~~
h = g o f 
h(x) = g(f(x))
~~~

how do you implement a monad in your language of choice?

i used to believe that functional paradigm would emerge as the winner, but now it seems that there is no winner, like fashion it goes in circles with new ideas from each paradigm influencing newer languages.

what is the future? Algebraic effects?


# language paradigms
- unstructured programming
  - assembly programming \
    control flow using goto statements
- structured programming \
  control flow constructs of selection (if/then/else) and repetition (while and for), block structures, and subroutines.
- procedural programming
- object oriented 
- functional programming


## C

In a low level language, like C, all errors must be handled explicitly by comparing the return value against known error values.

When the return value is reserved for error codes, all other return values must be passed as pointer arguments to the function. That is both counter-intuitive from the point of the caller and can result in a memory corruption if the function doesn’t handle the pointer correctly. It is also easy to make a mistake when comparing the error code to known error values, e.g. does `-1` indicate an error or is it `0`? 


~~~c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#define N 256
char buf[N];

int is_empty_buffer(char *buf) {
	return char == NULL || char[0] == '\0' ? 1 : 0;
}

int fd = open("/etc/passwd", O_RDONLY);
if (fd < 0) {
	if (fd == ENOENT) {
		// file does not exists
	}
	if (fd == EACCES) {
		// no read access
	}
}
int retval = read(STDIN_FILENO, &buf, N);
if (retval < 0) {
	// error occurred
	if (retval == EISDIR) {
		// file descriptor points to a directory, not a file
	}
}

int is_empty = is_empty_buffer(buf)
~~~

The only remaining question is, how do we differentiate between errors return from `openResult` on one hand and `readFileResult` on the other.
-->
<!--
~~~go
import (
   "io/ioutil
   "os"
)

func isEmptyBuffer(bs []byte) bool {
   return len(bs) == 0
}

file, err := os.Open("/etc/passwd")
if err != nil {
   if os.IsNotExist(err) {
   // file does not exist
   }
   if os.IsPermission(err) {
   // no read permission
   }
}

buf, err := ioutil.ReadAll(file)
if err != nil {
   // error occurred
}

isEmpty := isEmptyBuffer(buf)
~~~
-->

