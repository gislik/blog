<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
    <head>
        <meta charset="utf-8" />
        <meta name="referrer" content="no-referrer">

        <!-- Enable responsiveness on mobile devices-->
        <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" /> -->
        <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />

        <title>Gisli | Understanding Ethereum by studying the source code üß¨</title>

        <!-- Google Tag Manager -->
        <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
        new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
        j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
        'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
        })(window,document,'script','dataLayer','GTM-W95TH5W');</script>
        <!-- End Google Tag Manager -->

        <meta property="og:title" content="G√≠sli | Understanding Ethereum by studying the source code üß¨" />
        <meta property="og:description" content="My thoughts on blockchains and software" />
        <meta name="description" content="My thoughts on blockchains and software" />
        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@gislik" />
        
        <meta property="og:site_name" content="G√≠sli | Understanding Ethereum by studying the source code üß¨" />
        <meta property="og:url" content="https://gisli.hamstur.is/2020/08/understanding-ethereum-by-studying-the-source-code/" />

        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="../../../css/base.css" />
        <link rel="stylesheet" href="../../../css/custom.css" />
        <link rel="stylesheet" href="../../../css/syntax/kate.css" />
        <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&family=Rock+Salt&display=swap" rel="stylesheet">
        <link href="../../../css/fontawesome/fontawesome.css" rel="stylesheet">
        <link href="../../../css/fontawesome/brands.css" rel="stylesheet">
        <link href="../../../css/fontawesome/solid.css" rel="stylesheet">

        <link rel="icon" type="image/x-icon" href="../../../icon48x48.png" />
        <link rel="apple-touch-icon" sizes="48x48" href="../../../icon48x48.png" />
        <link rel="apple-touch-icon" sizes="72x72" href="../../../icon72x72.png" />
        <link rel="apple-touch-icon" sizes="96x96" href="../../../icon96x96.png" />
        <link rel="apple-touch-icon" sizes="144x144" href="../../../icon144x144.png" />
        <link rel="apple-touch-icon" sizes="192x192" href="../../../icon192x192.png" />
        <!-- <link rel="apple-touch-icon" sizes="256x256" href="" /> -->
        <!-- <link rel="apple-touch-icon" sizes="384x384" href="" /> -->
        <!-- <link rel="apple-touch-icon" sizes="512x512" href="" /> -->

        <link rel="alternate" type="application/atom+xml" title="Understanding Ethereum by studying the source code üß¨" href="../../../atom.xml">
    </head>
    <body>
        <!-- Google Tag Manager (noscript) -->
        <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-W95TH5W" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
        <!-- End Google Tag Manager (noscript) -->
        <a href="./#main" class="skip-link p-screen-reader-text">Skip to content</a>
        <header class="profile">
            <a class="profile-icon" href="../../../">
                <img src="../../../icon72x72.png" alt="profile picture">
            </a>
            <nav class="header">
                <a href="../../../about/">About</a>
                <a href="../../../decks/">Decks</a>
            </nav>
        </header>

        <main id="main" class="l-main">
        <article class="p-article">

    <header>
        <h2 class="c-title c-article__title">Understanding Ethereum by studying the source code üß¨</h2>
        <p class="c-article__meta">
            <time datetime="August 29, 2020">August 29, 2020</time>
        </p>
        <p class="c-article__meta">
            18 min read
        </p>
    </header>

    <section id="js-article" class="c-article__body">
        <div class="toc"><ul>
<li><a href="./#from-papers-to-code"><span class="toc-section-number">1</span> From papers üßª to code</a></li>
<li><a href="./#the-state-model"><span class="toc-section-number">2</span> The state model üíæ</a></li>
<li><a href="./#the-peer-to-peer-network"><span class="toc-section-number">3</span> The peer-to-peer network üï∏</a><ul>
<li><a href="./#networks-and-their-genesis"><span class="toc-section-number">3.1</span> Networks and their genesis</a></li>
<li><a href="./#connecting-via-bootnodes"><span class="toc-section-number">3.2</span> Connecting via bootnodes</a></li>
<li><a href="./#discovering-peers"><span class="toc-section-number">3.3</span> Discovering peers</a></li>
<li><a href="./#propagating-blocks"><span class="toc-section-number">3.4</span> Propagating blocks</a></li>
</ul></li>
<li><a href="./#state-transition"><span class="toc-section-number">4</span> State transition ‚è≠</a><ul>
<li><a href="./#validating-transactions"><span class="toc-section-number">4.1</span> Validating transactions</a></li>
<li><a href="./#executing-code-in-the-evm"><span class="toc-section-number">4.2</span> Executing code in the EVM</a></li>
</ul></li>
<li><a href="./#transacting-Ô∏è"><span class="toc-section-number">5</span> Transacting ‚öôÔ∏è</a><ul>
<li><a href="./#broadcasting-transactions"><span class="toc-section-number">5.1</span> Broadcasting transactions</a></li>
<li><a href="./#mining-transactions-into-a-block"><span class="toc-section-number">5.2</span> Mining transactions into a block ‚õè</a></li>
</ul></li>
</ul></div><h1 id="from-papers-to-code"><span class="header-section-number">1</span> From papers üßª to code</h1>
<p>The <a href="https://ethereum.org/en/whitepaper/">Ethereum Whitepaper</a> was published in 2013 and a year later some of the implementation details were expanded on in the <a href="https://ethereum.github.io/yellowpaper/paper.pdf">Ethereum Yellow Paper</a>. Originally there were three implementations of the Ethereum protocol written in Go, C++, and Python<a href="./#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. To understand the core concepts I decided to read both of the papers (again), clone the official <a href="https://github.com/ethereum/go-ethereum">Go implementation</a> repo <code>commit 979fc9689 (tag: v1.9.20)</code>, and study the relationship between the ideas and the actual implementation. The <a href="https://eth.wiki/">Ethereum Wiki</a> turned out to be a handy resource as well.</p>
<p>In blockchains users broadcast transactions using a peer-to-peer protocol to the entire network of nodes. The transactions remain in the node‚Äôs transaction pool ‚Äì which acts as a memory queue ‚Äì until miners dequeue transactions, marshal them into a block and perform the consensus protocol which orders the blocks, proposed by different miners, in a canonical sequence. Before appending a block to the chain the nodes verify that its validity and that the chain forms an uninterrupted sequence of blocks linked together by cryptographic hashes of the previous block, all the way from the genesis block.</p>
<h1 id="the-state-model"><span class="header-section-number">2</span> The state model üíæ</h1>
<p>In contrast to Bitcoin‚Äôs UTXO state model, in Ethereum the state consists of accounts, identified by an address. Accounts exist in two forms, externally owned accounts and contract accounts. All accounts store an ether balance, denominated in wei<a href="./#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> and a nonce, guarding against replay attacks. Externally owned accounts are controlled by private keys but contract accounts are controlled by their contract code, stored in the account, which is able to read and write to an internal storage.</p>
<p><a href="https://github.com/ethereum/go-ethereum/blob/v1.9.20/core/state/state_object.go#L100"><code>core/state/state_object.go</code></a></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb1-1"><a href="./#cb1-1"></a><span class="co">// Account is the Ethereum consensus representation of accounts.</span></span>
<span id="cb1-2"><a href="./#cb1-2"></a><span class="co">// These objects are stored in the main account trie.</span></span>
<span id="cb1-3"><a href="./#cb1-3"></a><span class="kw">type</span> Account <span class="kw">struct</span> {</span>
<span id="cb1-4"><a href="./#cb1-4"></a>	Nonce    <span class="dt">uint64</span></span>
<span id="cb1-5"><a href="./#cb1-5"></a>	Balance  *big.Int</span>
<span id="cb1-6"><a href="./#cb1-6"></a>	Root     common.Hash <span class="co">// merkle root of the storage trie</span></span>
<span id="cb1-7"><a href="./#cb1-7"></a>	CodeHash []<span class="dt">byte</span></span>
<span id="cb1-8"><a href="./#cb1-8"></a>}</span></code></pre></div>
<h1 id="the-peer-to-peer-network"><span class="header-section-number">3</span> The peer-to-peer network üï∏</h1>
<p>The <a href="https://github.com/ethereum/devp2p">specification</a> for the Ethereum peer-to-peer networking protocols includes specs for the ENR metadata format, a Node discovery protocol, a wire format, and the RLPx transport protocol. Ethereum nodes in the network are identified by a public key on the secp256k1 elliptic curve. The node address is the keccak256 hash of the uncompressed public key. Each node is expected to maintain a static private key which is saved and restored between sessions.</p>
<p>The Ethereum Node Records (ENR) is an open format for peer-to-peer connectivity information. A node record usually contains the network endpoints of a node, i.e.¬†the node‚Äôs IP addresses and ports. It also holds information about the node‚Äôs purpose on the network so others can decide whether to connect to it. The ENR includes the public key of the node publishing the record and a signature proving the authenticity of the record.</p>
<p><a href="https://github.com/ethereum/go-ethereum/blob/v1.9.20/p2p/enr/enr.go#L84"><code>p2p/enr/enr.go</code></a></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb2-1"><a href="./#cb2-1"></a><span class="co">// Record represents a node record. The zero value is an empty record.</span></span>
<span id="cb2-2"><a href="./#cb2-2"></a><span class="kw">type</span> Record <span class="kw">struct</span> {</span>
<span id="cb2-3"><a href="./#cb2-3"></a>	seq       <span class="dt">uint64</span> <span class="co">// sequence number</span></span>
<span id="cb2-4"><a href="./#cb2-4"></a>	signature []<span class="dt">byte</span> <span class="co">// the signature</span></span>
<span id="cb2-5"><a href="./#cb2-5"></a>	raw       []<span class="dt">byte</span> <span class="co">// RLP encoded record</span></span>
<span id="cb2-6"><a href="./#cb2-6"></a>	pairs     []pair <span class="co">// sorted list of all key/value pairs</span></span>
<span id="cb2-7"><a href="./#cb2-7"></a>}</span></code></pre></div>
<p><code>p2p/enode/node.go</code></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb3-1"><a href="./#cb3-1"></a><span class="co">// ID is a unique identifier for each node.</span></span>
<span id="cb3-2"><a href="./#cb3-2"></a><span class="kw">type</span> ID [<span class="dv">32</span>]<span class="dt">byte</span></span>
<span id="cb3-3"><a href="./#cb3-3"></a></span>
<span id="cb3-4"><a href="./#cb3-4"></a><span class="co">// Node represents a host on the network.</span></span>
<span id="cb3-5"><a href="./#cb3-5"></a><span class="kw">type</span> Node <span class="kw">struct</span> {</span>
<span id="cb3-6"><a href="./#cb3-6"></a>	r  enr.Record</span>
<span id="cb3-7"><a href="./#cb3-7"></a>	id ID</span>
<span id="cb3-8"><a href="./#cb3-8"></a>}</span>
<span id="cb3-9"><a href="./#cb3-9"></a></span>
<span id="cb3-10"><a href="./#cb3-10"></a><span class="co">// Load retrieves an entry from the underlying record.</span></span>
<span id="cb3-11"><a href="./#cb3-11"></a><span class="kw">func</span> (n *Node) Load(k enr.Entry) <span class="dt">error</span> {</span>
<span id="cb3-12"><a href="./#cb3-12"></a>	<span class="kw">return</span> n.r.Load(k)</span>
<span id="cb3-13"><a href="./#cb3-13"></a>}</span>
<span id="cb3-14"><a href="./#cb3-14"></a></span>
<span id="cb3-15"><a href="./#cb3-15"></a><span class="co">// IP returns the IP address of the node. This prefers IPv4 addresses.</span></span>
<span id="cb3-16"><a href="./#cb3-16"></a><span class="kw">func</span> (n *Node) IP() net.IP {</span>
<span id="cb3-17"><a href="./#cb3-17"></a>	<span class="kw">var</span> (</span>
<span id="cb3-18"><a href="./#cb3-18"></a>		ip4 enr.IPv4</span>
<span id="cb3-19"><a href="./#cb3-19"></a>		ip6 enr.IPv6</span>
<span id="cb3-20"><a href="./#cb3-20"></a>	)</span>
<span id="cb3-21"><a href="./#cb3-21"></a>	<span class="kw">if</span> n.Load(&amp;ip4) == <span class="ot">nil</span> {</span>
<span id="cb3-22"><a href="./#cb3-22"></a>		<span class="kw">return</span> net.IP(ip4)</span>
<span id="cb3-23"><a href="./#cb3-23"></a>	}</span>
<span id="cb3-24"><a href="./#cb3-24"></a>	<span class="kw">if</span> n.Load(&amp;ip6) == <span class="ot">nil</span> {</span>
<span id="cb3-25"><a href="./#cb3-25"></a>		<span class="kw">return</span> net.IP(ip6)</span>
<span id="cb3-26"><a href="./#cb3-26"></a>	}</span>
<span id="cb3-27"><a href="./#cb3-27"></a>	<span class="kw">return</span> <span class="ot">nil</span></span>
<span id="cb3-28"><a href="./#cb3-28"></a>}</span></code></pre></div>
<h2 id="networks-and-their-genesis"><span class="header-section-number">3.1</span> Networks and their genesis</h2>
<p>There are different Ethereum networks running simultaneously, mainnet and multiple testnets<a href="./#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, identified the chain identifier. The network configuration also includes parameters identifying specific blocks at which point a hardfork happened. Hardforks change the consensus rules in a backwards-incompatible way, such as altering the block reward or <a href="../../../2020/08/a-bref-history-of-ethereum/#a-fork-in-the-road">confiscating ether from a heist</a>.</p>
<p><a href="https://github.com/ethereum/go-ethereum/blob/v1.9.20/params/config.go#L56"><code>params/config.go</code></a></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb4-1"><a href="./#cb4-1"></a>	<span class="co">// MainnetChainConfig is the chain parameters to run a node on the main network.</span></span>
<span id="cb4-2"><a href="./#cb4-2"></a>	MainnetChainConfig = &amp;ChainConfig{</span>
<span id="cb4-3"><a href="./#cb4-3"></a>		ChainID:             big.NewInt(<span class="dv">1</span>),</span>
<span id="cb4-4"><a href="./#cb4-4"></a>		HomesteadBlock:      big.NewInt(<span class="dv">1150000</span>),</span>
<span id="cb4-5"><a href="./#cb4-5"></a>		DAOForkBlock:        big.NewInt(<span class="dv">1920000</span>),</span>
<span id="cb4-6"><a href="./#cb4-6"></a>		DAOForkSupport:      <span class="ot">true</span>,</span>
<span id="cb4-7"><a href="./#cb4-7"></a>		EIP150Block:         big.NewInt(<span class="dv">2463000</span>),</span>
<span id="cb4-8"><a href="./#cb4-8"></a>		EIP150Hash:          common.HexToHash(<span class="st">&quot;0x2086799aeebeae135c246c65021c82b4e15a2c451340993aacfd2751886514f0&quot;</span>),</span>
<span id="cb4-9"><a href="./#cb4-9"></a>		EIP155Block:         big.NewInt(<span class="dv">2675000</span>),</span>
<span id="cb4-10"><a href="./#cb4-10"></a>		EIP158Block:         big.NewInt(<span class="dv">2675000</span>),</span>
<span id="cb4-11"><a href="./#cb4-11"></a>		ByzantiumBlock:      big.NewInt(<span class="dv">4370000</span>),</span>
<span id="cb4-12"><a href="./#cb4-12"></a>		ConstantinopleBlock: big.NewInt(<span class="dv">7280000</span>),</span>
<span id="cb4-13"><a href="./#cb4-13"></a>		PetersburgBlock:     big.NewInt(<span class="dv">7280000</span>),</span>
<span id="cb4-14"><a href="./#cb4-14"></a>		IstanbulBlock:       big.NewInt(<span class="dv">9069000</span>),</span>
<span id="cb4-15"><a href="./#cb4-15"></a>		MuirGlacierBlock:    big.NewInt(<span class="dv">9200000</span>),</span>
<span id="cb4-16"><a href="./#cb4-16"></a>		Ethash:              <span class="bu">new</span>(EthashConfig),</span>
<span id="cb4-17"><a href="./#cb4-17"></a>	}</span></code></pre></div>
<p>All nodes in a network must agree on the genesis block which anchors the chain of trust. In addition to standard block fields, the initial ether allocation from the pre-sale is configured in the genesis. The data is hardcoded in <a href="https://eth.wiki/en/fundamentals/design-rationale#rlp">RLP</a>-encoding which is decoded prior to account allocation.</p>
<p><a href="https://github.com/ethereum/go-ethereum/blob/v1.9.20/core/genesis.go#L67"><code>core/genesis.go</code></a></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb5-1"><a href="./#cb5-1"></a><span class="co">// GenesisAlloc specifies the initial state that is part of the genesis block.</span></span>
<span id="cb5-2"><a href="./#cb5-2"></a><span class="kw">type</span> GenesisAlloc <span class="kw">map</span>[common.Address]GenesisAccount</span>
<span id="cb5-3"><a href="./#cb5-3"></a></span>
<span id="cb5-4"><a href="./#cb5-4"></a><span class="co">// DefaultGenesisBlock returns the Ethereum main net genesis block.</span></span>
<span id="cb5-5"><a href="./#cb5-5"></a><span class="kw">func</span> DefaultGenesisBlock() *Genesis {</span>
<span id="cb5-6"><a href="./#cb5-6"></a>	<span class="kw">return</span> &amp;Genesis{</span>
<span id="cb5-7"><a href="./#cb5-7"></a>		Config:     params.MainnetChainConfig,</span>
<span id="cb5-8"><a href="./#cb5-8"></a>		Nonce:      <span class="dv">66</span>,</span>
<span id="cb5-9"><a href="./#cb5-9"></a>		ExtraData:  hexutil.MustDecode(<span class="st">&quot;0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa&quot;</span>),</span>
<span id="cb5-10"><a href="./#cb5-10"></a>		GasLimit:   <span class="dv">5000</span>,</span>
<span id="cb5-11"><a href="./#cb5-11"></a>		Difficulty: big.NewInt(<span class="dv">17179869184</span>),</span>
<span id="cb5-12"><a href="./#cb5-12"></a>		Alloc:      decodePrealloc(mainnetAllocData),</span>
<span id="cb5-13"><a href="./#cb5-13"></a>	}</span>
<span id="cb5-14"><a href="./#cb5-14"></a>}</span>
<span id="cb5-15"><a href="./#cb5-15"></a></span>
<span id="cb5-16"><a href="./#cb5-16"></a><span class="kw">func</span> decodePrealloc(data <span class="dt">string</span>) GenesisAlloc {</span>
<span id="cb5-17"><a href="./#cb5-17"></a>	<span class="kw">var</span> p []<span class="kw">struct</span>{ Addr, Balance *big.Int }</span>
<span id="cb5-18"><a href="./#cb5-18"></a>	<span class="kw">if</span> err := rlp.NewStream(strings.NewReader(data), <span class="dv">0</span>).Decode(&amp;p); err != <span class="ot">nil</span> {</span>
<span id="cb5-19"><a href="./#cb5-19"></a>		<span class="bu">panic</span>(err)</span>
<span id="cb5-20"><a href="./#cb5-20"></a>	}</span>
<span id="cb5-21"><a href="./#cb5-21"></a>	ga := <span class="bu">make</span>(GenesisAlloc, <span class="bu">len</span>(p))</span>
<span id="cb5-22"><a href="./#cb5-22"></a>	<span class="kw">for</span> _, account := <span class="kw">range</span> p {</span>
<span id="cb5-23"><a href="./#cb5-23"></a>		ga[common.BigToAddress(account.Addr)] = GenesisAccount{Balance: account.Balance}</span>
<span id="cb5-24"><a href="./#cb5-24"></a>	}</span>
<span id="cb5-25"><a href="./#cb5-25"></a>	<span class="kw">return</span> ga</span>
<span id="cb5-26"><a href="./#cb5-26"></a>}</span></code></pre></div>
<h2 id="connecting-via-bootnodes"><span class="header-section-number">3.2</span> Connecting via bootnodes</h2>
<p>Nodes discover peers in the network with the assistance of bootnodes which can either be provided as a command line flag on startup or the node can rely on a default set of hardcoded bootnodes run by the Ethereum Foundation. As peers are discovered, the node tries to connect to them and initiates the handshake protocol. A list is maintained of successfully connected peers<a href="./#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
<p><a href="https://github.com/ethereum/go-ethereum/blob/v1.9.20/params/bootnodes.go#L23"><code>params/bootnodes.go</code></a></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb6-1"><a href="./#cb6-1"></a><span class="co">// MainnetBootnodes are the enode URLs of the P2P bootstrap nodes running on</span></span>
<span id="cb6-2"><a href="./#cb6-2"></a><span class="co">// the main Ethereum network.</span></span>
<span id="cb6-3"><a href="./#cb6-3"></a><span class="kw">var</span> MainnetBootnodes = []<span class="dt">string</span>{</span>
<span id="cb6-4"><a href="./#cb6-4"></a>	<span class="co">// Ethereum Foundation Go Bootnodes</span></span>
<span id="cb6-5"><a href="./#cb6-5"></a>	<span class="st">&quot;enode://d860a01f9722d78051619d1e2351aba3f43f943f6f00718d1b9baa4101932a1f5011f16bb2b1bb35db20d6fe28fa0bf09636d26a87d31de9ec6203eeedb1f666@18.138.108.67:30303&quot;</span>,   <span class="co">// bootnode-aws-ap-southeast-1-001</span></span>
<span id="cb6-6"><a href="./#cb6-6"></a>	<span class="st">&quot;enode://22a8232c3abc76a16ae9d6c3b164f98775fe226f0917b0ca871128a74a8e9630b458460865bab457221f1d448dd9791d24c4e5d88786180ac185df813a68d4de@3.209.45.79:30303&quot;</span>,     <span class="co">// bootnode-aws-us-east-1-001</span></span>
<span id="cb6-7"><a href="./#cb6-7"></a>	<span class="st">&quot;enode://ca6de62fce278f96aea6ec5a2daadb877e51651247cb96ee310a318def462913b653963c155a0ef6c7d50048bba6e6cea881130857413d9f50a621546b590758@34.255.23.113:30303&quot;</span>,   <span class="co">// bootnode-aws-eu-west-1-001</span></span>
<span id="cb6-8"><a href="./#cb6-8"></a>	<span class="st">&quot;enode://279944d8dcd428dffaa7436f25ca0ca43ae19e7bcf94a8fb7d1641651f92d121e972ac2e8f381414b80cc8e5555811c2ec6e1a99bb009b3f53c4c69923e11bd8@35.158.244.151:30303&quot;</span>,  <span class="co">// bootnode-aws-eu-central-1-001</span></span>
<span id="cb6-9"><a href="./#cb6-9"></a>	<span class="st">&quot;enode://8499da03c47d637b20eee24eec3c356c9a2e6148d6fe25ca195c7949ab8ec2c03e3556126b0d7ed644675e78c4318b08691b7b57de10e5f0d40d05b09238fa0a@52.187.207.27:30303&quot;</span>,   <span class="co">// bootnode-azure-australiaeast-001</span></span>
<span id="cb6-10"><a href="./#cb6-10"></a>	<span class="st">&quot;enode://103858bdb88756c71f15e9b5e09b56dc1be52f0a5021d46301dbbfb7e130029cc9d0d6f73f693bc29b665770fff7da4d34f3c6379fe12721b5d7a0bcb5ca1fc1@191.234.162.198:30303&quot;</span>, <span class="co">// bootnode-azure-brazilsouth-001</span></span>
<span id="cb6-11"><a href="./#cb6-11"></a>	<span class="st">&quot;enode://715171f50508aba88aecd1250af392a45a330af91d7b90701c436b618c86aaa1589c9184561907bebbb56439b8f8787bc01f49a7c77276c58c1b09822d75e8e8@52.231.165.108:30303&quot;</span>,  <span class="co">// bootnode-azure-koreasouth-001</span></span>
<span id="cb6-12"><a href="./#cb6-12"></a>	<span class="st">&quot;enode://5d6d7cd20d6da4bb83a1d28cadb5d409b64edf314c0335df658c1a54e32c7c4a7ab7823d57c39b6a757556e68ff1df17c748b698544a55cb488b52479a92b60f@104.42.217.25:30303&quot;</span>,   <span class="co">// bootnode-azure-westus-001</span></span>
<span id="cb6-13"><a href="./#cb6-13"></a>}</span></code></pre></div>
<h2 id="discovering-peers"><span class="header-section-number">3.3</span> Discovering peers</h2>
<p>The discovery protocol relies on a Kademlia-like DHT that stores information about Ethereum nodes. Participants in the discovery protocol are expected to maintain a ENR containing up-to-date information. To resolve the current record of any node public key, a DHT lookup is performed and when the node is found, the ENR is requested directly from the peer.</p>
<p><a href="https://github.com/ethereum/go-ethereum/blob/v1.9.20/p2p/discover/v4_udp.go#L339"><code>p2p/discover/v4_udp.go</code></a></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb7-1"><a href="./#cb7-1"></a><span class="co">// RequestENR sends enrRequest to the given node and waits for a response.</span></span>
<span id="cb7-2"><a href="./#cb7-2"></a><span class="kw">func</span> (t *UDPv4) RequestENR(n *enode.Node) (*enode.Node, <span class="dt">error</span>) {</span>
<span id="cb7-3"><a href="./#cb7-3"></a>	addr := &amp;net.UDPAddr{IP: n.IP(), Port: n.UDP()}</span>
<span id="cb7-4"><a href="./#cb7-4"></a>	t.ensureBond(n.ID(), addr)</span>
<span id="cb7-5"><a href="./#cb7-5"></a></span>
<span id="cb7-6"><a href="./#cb7-6"></a>	req := &amp;enrRequestV4{</span>
<span id="cb7-7"><a href="./#cb7-7"></a>		Expiration: <span class="dt">uint64</span>(time.Now().Add(expiration).Unix()),</span>
<span id="cb7-8"><a href="./#cb7-8"></a>	}</span>
<span id="cb7-9"><a href="./#cb7-9"></a>	packet, hash, err := t.encode(t.priv, req)</span>
<span id="cb7-10"><a href="./#cb7-10"></a>	<span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb7-11"><a href="./#cb7-11"></a>		<span class="kw">return</span> <span class="ot">nil</span>, err</span>
<span id="cb7-12"><a href="./#cb7-12"></a>	}</span>
<span id="cb7-13"><a href="./#cb7-13"></a>	<span class="co">// Add a matcher for the reply to the pending reply queue. Responses are matched if</span></span>
<span id="cb7-14"><a href="./#cb7-14"></a>	<span class="co">// they reference the request we're about to send.</span></span>
<span id="cb7-15"><a href="./#cb7-15"></a>	rm := t.pending(n.ID(), addr.IP, p_enrResponseV4, <span class="kw">func</span>(r <span class="kw">interface</span>{}) (matched <span class="dt">bool</span>, requestDone <span class="dt">bool</span>) {</span>
<span id="cb7-16"><a href="./#cb7-16"></a>		matched = bytes.Equal(r.(*enrResponseV4).ReplyTok, hash)</span>
<span id="cb7-17"><a href="./#cb7-17"></a>		<span class="kw">return</span> matched, matched</span>
<span id="cb7-18"><a href="./#cb7-18"></a>	})</span>
<span id="cb7-19"><a href="./#cb7-19"></a>	<span class="co">// Send the packet and wait for the reply.</span></span>
<span id="cb7-20"><a href="./#cb7-20"></a>	t.write(addr, n.ID(), req.name(), packet)</span>
<span id="cb7-21"><a href="./#cb7-21"></a>	<span class="kw">if</span> err := &lt;-rm.errc; err != <span class="ot">nil</span> {</span>
<span id="cb7-22"><a href="./#cb7-22"></a>		<span class="kw">return</span> <span class="ot">nil</span>, err</span>
<span id="cb7-23"><a href="./#cb7-23"></a>	}</span>
<span id="cb7-24"><a href="./#cb7-24"></a>	<span class="co">// Verify the response record.</span></span>
<span id="cb7-25"><a href="./#cb7-25"></a>	respN, err := enode.New(enode.ValidSchemes, &amp;rm.reply.(*enrResponseV4).Record)</span>
<span id="cb7-26"><a href="./#cb7-26"></a>	<span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb7-27"><a href="./#cb7-27"></a>		<span class="kw">return</span> <span class="ot">nil</span>, err</span>
<span id="cb7-28"><a href="./#cb7-28"></a>	}</span>
<span id="cb7-29"><a href="./#cb7-29"></a>	<span class="kw">if</span> respN.ID() != n.ID() {</span>
<span id="cb7-30"><a href="./#cb7-30"></a>		<span class="kw">return</span> <span class="ot">nil</span>, fmt.Errorf(<span class="st">&quot;invalid ID in response record&quot;</span>)</span>
<span id="cb7-31"><a href="./#cb7-31"></a>	}</span>
<span id="cb7-32"><a href="./#cb7-32"></a>	<span class="kw">if</span> respN.Seq() &lt; n.Seq() {</span>
<span id="cb7-33"><a href="./#cb7-33"></a>		<span class="kw">return</span> n, <span class="ot">nil</span> <span class="co">// response record is older</span></span>
<span id="cb7-34"><a href="./#cb7-34"></a>	}</span>
<span id="cb7-35"><a href="./#cb7-35"></a>	<span class="kw">if</span> err := netutil.CheckRelayIP(addr.IP, respN.IP()); err != <span class="ot">nil</span> {</span>
<span id="cb7-36"><a href="./#cb7-36"></a>		<span class="kw">return</span> <span class="ot">nil</span>, fmt.Errorf(<span class="st">&quot;invalid IP in response record: %v&quot;</span>, err)</span>
<span id="cb7-37"><a href="./#cb7-37"></a>	}</span>
<span id="cb7-38"><a href="./#cb7-38"></a>	<span class="kw">return</span> respN, <span class="ot">nil</span></span>
<span id="cb7-39"><a href="./#cb7-39"></a>}</span></code></pre></div>
<h2 id="propagating-blocks"><span class="header-section-number">3.4</span> Propagating blocks</h2>
<p>Now that our node is connected to its peers it must download all blocks from genesis block to the latest block. The total difficulty is used to determine which peer has the heaviest chain. The node always verifies the proof-of-work values in the block headers and then can either recreate the state by downloading the transactions and executing them in the EVM or by downloading merkle tree nodes and contract code incrementally until the entire tree is synchronized. Subsequent blocks are propagated to all nodes in the network in two steps; first a new block is announced and nodes perform basic validation before relaying the announcement to a small fraction of connected peers then transactions contained in the block are executed and if valid a hash of the block is propagated to peers it didn‚Äôt notify earlier. Those peers may need to request the full block from a node they are connected to.</p>
<p>Ethereum blocks are produced on average every 15 seconds. Contrasted with Bitcoin‚Äôs 10 minute block times, this increases both throughput and shortens finality at the expense of a higher likelihood that two different blocks are proposed at the same hight. Uncles are stale blocks that contribute to the security of the chain but are not considered the canonical truth for that particular chain height. Instead of orphaning stale blocks, Ethereum pays for uncles adding to the security of the chain. The canonical chain is therefore not the necessarily the longest chain but the heaviest when all work, including work performed by uncles, is counted.</p>
<p>The block header contains a number of interesting hashes which provide cryptographic proofs of data authenticity which has possibly been acquired from different peers. The parent hash is the hash of the block prior to the current block which is the keccak256 hash of the RLP encoded block header. The uncle hash and transactions hash are calculated in the same way on the encoded block headers of the uncles and the transactions, respectively. The state hash is a hash of the root node of a Merkle Patricia tree<a href="./#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>, a mapping between addresses and account states after all transactions are executed, serialized as RLP.</p>
<p><a href="https://github.com/ethereum/go-ethereum/blob/v1.9.20/core/types/block.go#L168"><code>core/types/block.go</code></a></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb8-1"><a href="./#cb8-1"></a><span class="co">// Block represents an entire block in the Ethereum blockchain.</span></span>
<span id="cb8-2"><a href="./#cb8-2"></a><span class="kw">type</span> Block <span class="kw">struct</span> {</span>
<span id="cb8-3"><a href="./#cb8-3"></a>	header       *Header</span>
<span id="cb8-4"><a href="./#cb8-4"></a>	uncles       []*Header</span>
<span id="cb8-5"><a href="./#cb8-5"></a>	transactions Transactions</span>
<span id="cb8-6"><a href="./#cb8-6"></a></span>
<span id="cb8-7"><a href="./#cb8-7"></a>	<span class="co">// caches</span></span>
<span id="cb8-8"><a href="./#cb8-8"></a>	hash atomic.Value</span>
<span id="cb8-9"><a href="./#cb8-9"></a>	size atomic.Value</span>
<span id="cb8-10"><a href="./#cb8-10"></a></span>
<span id="cb8-11"><a href="./#cb8-11"></a>	<span class="co">// Td is used by package core to store the total difficulty</span></span>
<span id="cb8-12"><a href="./#cb8-12"></a>	<span class="co">// of the chain up to and including the block.</span></span>
<span id="cb8-13"><a href="./#cb8-13"></a>	td *big.Int</span>
<span id="cb8-14"><a href="./#cb8-14"></a></span>
<span id="cb8-15"><a href="./#cb8-15"></a>	<span class="co">// These fields are used by package eth to track</span></span>
<span id="cb8-16"><a href="./#cb8-16"></a>	<span class="co">// inter-peer block relay.</span></span>
<span id="cb8-17"><a href="./#cb8-17"></a>	ReceivedAt   time.Time</span>
<span id="cb8-18"><a href="./#cb8-18"></a>	ReceivedFrom <span class="kw">interface</span>{}</span>
<span id="cb8-19"><a href="./#cb8-19"></a>}</span>
<span id="cb8-20"><a href="./#cb8-20"></a></span>
<span id="cb8-21"><a href="./#cb8-21"></a><span class="co">// Hash returns the keccak256 hash of b's header.</span></span>
<span id="cb8-22"><a href="./#cb8-22"></a><span class="co">// The hash is computed on the first call and cached thereafter.</span></span>
<span id="cb8-23"><a href="./#cb8-23"></a><span class="kw">func</span> (b *Block) Hash() common.Hash {</span>
<span id="cb8-24"><a href="./#cb8-24"></a>	<span class="kw">if</span> hash := b.hash.Load(); hash != <span class="ot">nil</span> {</span>
<span id="cb8-25"><a href="./#cb8-25"></a>		<span class="kw">return</span> hash.(common.Hash)</span>
<span id="cb8-26"><a href="./#cb8-26"></a>	}</span>
<span id="cb8-27"><a href="./#cb8-27"></a>	v := b.header.Hash()</span>
<span id="cb8-28"><a href="./#cb8-28"></a>	b.hash.Store(v)</span>
<span id="cb8-29"><a href="./#cb8-29"></a>	<span class="kw">return</span> v</span>
<span id="cb8-30"><a href="./#cb8-30"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb9-1"><a href="./#cb9-1"></a><span class="co">// Header represents a block header in the Ethereum blockchain.</span></span>
<span id="cb9-2"><a href="./#cb9-2"></a><span class="kw">type</span> Header <span class="kw">struct</span> {</span>
<span id="cb9-3"><a href="./#cb9-3"></a>	ParentHash  common.Hash    <span class="st">`json:&quot;parentHash&quot;       gencodec:&quot;required&quot;`</span></span>
<span id="cb9-4"><a href="./#cb9-4"></a>	UncleHash   common.Hash    <span class="st">`json:&quot;sha3Uncles&quot;       gencodec:&quot;required&quot;`</span></span>
<span id="cb9-5"><a href="./#cb9-5"></a>	Coinbase    common.Address <span class="st">`json:&quot;miner&quot;            gencodec:&quot;required&quot;`</span></span>
<span id="cb9-6"><a href="./#cb9-6"></a>	Root        common.Hash    <span class="st">`json:&quot;stateRoot&quot;        gencodec:&quot;required&quot;`</span></span>
<span id="cb9-7"><a href="./#cb9-7"></a>	TxHash      common.Hash    <span class="st">`json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;`</span></span>
<span id="cb9-8"><a href="./#cb9-8"></a>	ReceiptHash common.Hash    <span class="st">`json:&quot;receiptsRoot&quot;     gencodec:&quot;required&quot;`</span></span>
<span id="cb9-9"><a href="./#cb9-9"></a>	Bloom       Bloom          <span class="st">`json:&quot;logsBloom&quot;        gencodec:&quot;required&quot;`</span></span>
<span id="cb9-10"><a href="./#cb9-10"></a>	Difficulty  *big.Int       <span class="st">`json:&quot;difficulty&quot;       gencodec:&quot;required&quot;`</span></span>
<span id="cb9-11"><a href="./#cb9-11"></a>	Number      *big.Int       <span class="st">`json:&quot;number&quot;           gencodec:&quot;required&quot;`</span></span>
<span id="cb9-12"><a href="./#cb9-12"></a>	GasLimit    <span class="dt">uint64</span>         <span class="st">`json:&quot;gasLimit&quot;         gencodec:&quot;required&quot;`</span></span>
<span id="cb9-13"><a href="./#cb9-13"></a>	GasUsed     <span class="dt">uint64</span>         <span class="st">`json:&quot;gasUsed&quot;          gencodec:&quot;required&quot;`</span></span>
<span id="cb9-14"><a href="./#cb9-14"></a>	Time        <span class="dt">uint64</span>         <span class="st">`json:&quot;timestamp&quot;        gencodec:&quot;required&quot;`</span></span>
<span id="cb9-15"><a href="./#cb9-15"></a>	Extra       []<span class="dt">byte</span>         <span class="st">`json:&quot;extraData&quot;        gencodec:&quot;required&quot;`</span></span>
<span id="cb9-16"><a href="./#cb9-16"></a>	MixDigest   common.Hash    <span class="st">`json:&quot;mixHash&quot;`</span></span>
<span id="cb9-17"><a href="./#cb9-17"></a>	Nonce       BlockNonce     <span class="st">`json:&quot;nonce&quot;`</span></span>
<span id="cb9-18"><a href="./#cb9-18"></a>}</span>
<span id="cb9-19"><a href="./#cb9-19"></a></span>
<span id="cb9-20"><a href="./#cb9-20"></a><span class="co">// Hash returns the block hash of the header, which is simply the keccak256 hash of its</span></span>
<span id="cb9-21"><a href="./#cb9-21"></a><span class="co">// RLP encoding.</span></span>
<span id="cb9-22"><a href="./#cb9-22"></a><span class="kw">func</span> (h *Header) Hash() common.Hash {</span>
<span id="cb9-23"><a href="./#cb9-23"></a>	<span class="kw">return</span> rlpHash(h)</span>
<span id="cb9-24"><a href="./#cb9-24"></a>}</span>
<span id="cb9-25"><a href="./#cb9-25"></a></span>
<span id="cb9-26"><a href="./#cb9-26"></a><span class="kw">func</span> rlpHash(x <span class="kw">interface</span>{}) (h common.Hash) {</span>
<span id="cb9-27"><a href="./#cb9-27"></a>	sha := hasherPool.Get().(crypto.KeccakState)</span>
<span id="cb9-28"><a href="./#cb9-28"></a>	<span class="kw">defer</span> hasherPool.Put(sha)</span>
<span id="cb9-29"><a href="./#cb9-29"></a>	sha.Reset()</span>
<span id="cb9-30"><a href="./#cb9-30"></a>	rlp.Encode(sha, x)</span>
<span id="cb9-31"><a href="./#cb9-31"></a>	sha.Read(h[:])</span>
<span id="cb9-32"><a href="./#cb9-32"></a>	<span class="kw">return</span> h</span>
<span id="cb9-33"><a href="./#cb9-33"></a>}</span></code></pre></div>
<h1 id="state-transition"><span class="header-section-number">4</span> State transition ‚è≠</h1>
<h2 id="validating-transactions"><span class="header-section-number">4.1</span> Validating transactions</h2>
<p>If a transaction amount is specified that amount of ether denominated in wei is sent to another account identified by the recipient address. If the recipients account does not exist it is created. The sender account is derived from the signature values which must be valid and simultaneously authorize the account state change. The nonce in the transaction must be exactly one higher than the nonce in the sender account state essentially guarding against race conditions of two competing transactions trying to modify the same account state. The transfer transaction fails if the sender account balance has insufficient ether compared to the transaction amount.</p>
<p><a href="https://github.com/ethereum/go-ethereum/blob/v1.9.20/core/types/transaction.go#L39"><code>core/types/transaction.go</code></a></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb10-1"><a href="./#cb10-1"></a><span class="kw">type</span> Transaction <span class="kw">struct</span> {</span>
<span id="cb10-2"><a href="./#cb10-2"></a>	data txdata</span>
<span id="cb10-3"><a href="./#cb10-3"></a>	<span class="co">// caches</span></span>
<span id="cb10-4"><a href="./#cb10-4"></a>	hash atomic.Value</span>
<span id="cb10-5"><a href="./#cb10-5"></a>	size atomic.Value</span>
<span id="cb10-6"><a href="./#cb10-6"></a>	from atomic.Value</span>
<span id="cb10-7"><a href="./#cb10-7"></a>}</span>
<span id="cb10-8"><a href="./#cb10-8"></a></span>
<span id="cb10-9"><a href="./#cb10-9"></a><span class="kw">type</span> txdata <span class="kw">struct</span> {</span>
<span id="cb10-10"><a href="./#cb10-10"></a>	AccountNonce <span class="dt">uint64</span>          <span class="st">`json:&quot;nonce&quot;    gencodec:&quot;required&quot;`</span></span>
<span id="cb10-11"><a href="./#cb10-11"></a>	Price        *big.Int        <span class="st">`json:&quot;gasPrice&quot; gencodec:&quot;required&quot;`</span></span>
<span id="cb10-12"><a href="./#cb10-12"></a>	GasLimit     <span class="dt">uint64</span>          <span class="st">`json:&quot;gas&quot;      gencodec:&quot;required&quot;`</span></span>
<span id="cb10-13"><a href="./#cb10-13"></a>	Recipient    *common.Address <span class="st">`json:&quot;to&quot;       rlp:&quot;nil&quot;`</span> <span class="co">// nil means contract creation</span></span>
<span id="cb10-14"><a href="./#cb10-14"></a>	Amount       *big.Int        <span class="st">`json:&quot;value&quot;    gencodec:&quot;required&quot;`</span></span>
<span id="cb10-15"><a href="./#cb10-15"></a>	Payload      []<span class="dt">byte</span>          <span class="st">`json:&quot;input&quot;    gencodec:&quot;required&quot;`</span></span>
<span id="cb10-16"><a href="./#cb10-16"></a></span>
<span id="cb10-17"><a href="./#cb10-17"></a>	<span class="co">// Signature values</span></span>
<span id="cb10-18"><a href="./#cb10-18"></a>	V *big.Int <span class="st">`json:&quot;v&quot; gencodec:&quot;required&quot;`</span></span>
<span id="cb10-19"><a href="./#cb10-19"></a>	R *big.Int <span class="st">`json:&quot;r&quot; gencodec:&quot;required&quot;`</span></span>
<span id="cb10-20"><a href="./#cb10-20"></a>	S *big.Int <span class="st">`json:&quot;s&quot; gencodec:&quot;required&quot;`</span></span>
<span id="cb10-21"><a href="./#cb10-21"></a></span>
<span id="cb10-22"><a href="./#cb10-22"></a>	<span class="co">// This is only used when marshaling to JSON.</span></span>
<span id="cb10-23"><a href="./#cb10-23"></a>	Hash *common.Hash <span class="st">`json:&quot;hash&quot; rlp:&quot;-&quot;`</span></span>
<span id="cb10-24"><a href="./#cb10-24"></a>}</span></code></pre></div>
<p><a href="https://github.com/ethereum/go-ethereum/blob/v1.9.20/core/types/transaction_signing.go#L105"><code>core/types/transaction_signing.go</code></a></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb11-1"><a href="./#cb11-1"></a><span class="co">// EIP155Transaction implements Signer using the EIP155 rules.</span></span>
<span id="cb11-2"><a href="./#cb11-2"></a><span class="kw">type</span> EIP155Signer <span class="kw">struct</span> {</span>
<span id="cb11-3"><a href="./#cb11-3"></a>	chainId, chainIdMul *big.Int</span>
<span id="cb11-4"><a href="./#cb11-4"></a>}</span>
<span id="cb11-5"><a href="./#cb11-5"></a></span>
<span id="cb11-6"><a href="./#cb11-6"></a><span class="co">// Hash returns the hash to be signed by the sender.</span></span>
<span id="cb11-7"><a href="./#cb11-7"></a><span class="co">// It does not uniquely identify the transaction.</span></span>
<span id="cb11-8"><a href="./#cb11-8"></a><span class="kw">func</span> (s EIP155Signer) Hash(tx *Transaction) common.Hash {</span>
<span id="cb11-9"><a href="./#cb11-9"></a>	<span class="kw">return</span> rlpHash([]<span class="kw">interface</span>{}{</span>
<span id="cb11-10"><a href="./#cb11-10"></a>		tx.data.AccountNonce,</span>
<span id="cb11-11"><a href="./#cb11-11"></a>		tx.data.Price,</span>
<span id="cb11-12"><a href="./#cb11-12"></a>		tx.data.GasLimit,</span>
<span id="cb11-13"><a href="./#cb11-13"></a>		tx.data.Recipient,</span>
<span id="cb11-14"><a href="./#cb11-14"></a>		tx.data.Amount,</span>
<span id="cb11-15"><a href="./#cb11-15"></a>		tx.data.Payload,</span>
<span id="cb11-16"><a href="./#cb11-16"></a>		s.chainId, <span class="dt">uint</span>(<span class="dv">0</span>), <span class="dt">uint</span>(<span class="dv">0</span>),</span>
<span id="cb11-17"><a href="./#cb11-17"></a>	})</span>
<span id="cb11-18"><a href="./#cb11-18"></a>}</span>
<span id="cb11-19"><a href="./#cb11-19"></a></span>
<span id="cb11-20"><a href="./#cb11-20"></a><span class="kw">func</span> (s EIP155Signer) Sender(tx *Transaction) (common.Address, <span class="dt">error</span>) {</span>
<span id="cb11-21"><a href="./#cb11-21"></a>	<span class="kw">if</span> !tx.Protected() {</span>
<span id="cb11-22"><a href="./#cb11-22"></a>		<span class="kw">return</span> HomesteadSigner{}.Sender(tx)</span>
<span id="cb11-23"><a href="./#cb11-23"></a>	}</span>
<span id="cb11-24"><a href="./#cb11-24"></a>	<span class="kw">if</span> tx.ChainId().Cmp(s.chainId) != <span class="dv">0</span> {</span>
<span id="cb11-25"><a href="./#cb11-25"></a>		<span class="kw">return</span> common.Address{}, ErrInvalidChainId</span>
<span id="cb11-26"><a href="./#cb11-26"></a>	}</span>
<span id="cb11-27"><a href="./#cb11-27"></a>	V := <span class="bu">new</span>(big.Int).Sub(tx.data.V, s.chainIdMul)</span>
<span id="cb11-28"><a href="./#cb11-28"></a>	V.Sub(V, big8)</span>
<span id="cb11-29"><a href="./#cb11-29"></a>	<span class="kw">return</span> recoverPlain(s.Hash(tx), tx.data.R, tx.data.S, V, <span class="ot">true</span>)</span>
<span id="cb11-30"><a href="./#cb11-30"></a>}</span>
<span id="cb11-31"><a href="./#cb11-31"></a></span>
<span id="cb11-32"><a href="./#cb11-32"></a><span class="kw">func</span> recoverPlain(sighash common.Hash, R, S, Vb *big.Int, homestead <span class="dt">bool</span>) (common.Address, <span class="dt">error</span>) {</span>
<span id="cb11-33"><a href="./#cb11-33"></a>	<span class="kw">if</span> Vb.BitLen() &gt; <span class="dv">8</span> {</span>
<span id="cb11-34"><a href="./#cb11-34"></a>		<span class="kw">return</span> common.Address{}, ErrInvalidSig</span>
<span id="cb11-35"><a href="./#cb11-35"></a>	}</span>
<span id="cb11-36"><a href="./#cb11-36"></a>	V := <span class="dt">byte</span>(Vb.Uint64() - <span class="dv">27</span>)</span>
<span id="cb11-37"><a href="./#cb11-37"></a>	<span class="kw">if</span> !crypto.ValidateSignatureValues(V, R, S, homestead) {</span>
<span id="cb11-38"><a href="./#cb11-38"></a>		<span class="kw">return</span> common.Address{}, ErrInvalidSig</span>
<span id="cb11-39"><a href="./#cb11-39"></a>	}</span>
<span id="cb11-40"><a href="./#cb11-40"></a>	<span class="co">// encode the signature in uncompressed format</span></span>
<span id="cb11-41"><a href="./#cb11-41"></a>	r, s := R.Bytes(), S.Bytes()</span>
<span id="cb11-42"><a href="./#cb11-42"></a>	sig := <span class="bu">make</span>([]<span class="dt">byte</span>, crypto.SignatureLength)</span>
<span id="cb11-43"><a href="./#cb11-43"></a>	<span class="bu">copy</span>(sig[<span class="dv">32</span>-<span class="bu">len</span>(r):<span class="dv">32</span>], r)</span>
<span id="cb11-44"><a href="./#cb11-44"></a>	<span class="bu">copy</span>(sig[<span class="dv">64</span>-<span class="bu">len</span>(s):<span class="dv">64</span>], s)</span>
<span id="cb11-45"><a href="./#cb11-45"></a>	sig[<span class="dv">64</span>] = V</span>
<span id="cb11-46"><a href="./#cb11-46"></a>	<span class="co">// recover the public key from the signature</span></span>
<span id="cb11-47"><a href="./#cb11-47"></a>	pub, err := crypto.Ecrecover(sighash[:], sig)</span>
<span id="cb11-48"><a href="./#cb11-48"></a>	<span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb11-49"><a href="./#cb11-49"></a>		<span class="kw">return</span> common.Address{}, err</span>
<span id="cb11-50"><a href="./#cb11-50"></a>	}</span>
<span id="cb11-51"><a href="./#cb11-51"></a>	<span class="kw">if</span> <span class="bu">len</span>(pub) == <span class="dv">0</span> || pub[<span class="dv">0</span>] != <span class="dv">4</span> {</span>
<span id="cb11-52"><a href="./#cb11-52"></a>		<span class="kw">return</span> common.Address{}, errors.New(<span class="st">&quot;invalid public key&quot;</span>)</span>
<span id="cb11-53"><a href="./#cb11-53"></a>	}</span>
<span id="cb11-54"><a href="./#cb11-54"></a>	<span class="kw">var</span> addr common.Address</span>
<span id="cb11-55"><a href="./#cb11-55"></a>	<span class="bu">copy</span>(addr[:], crypto.Keccak256(pub[<span class="dv">1</span>:])[<span class="dv">12</span>:])</span>
<span id="cb11-56"><a href="./#cb11-56"></a>	<span class="kw">return</span> addr, <span class="ot">nil</span></span>
<span id="cb11-57"><a href="./#cb11-57"></a>}</span></code></pre></div>
<p><a href="https://github.com/ethereum/go-ethereum/blob/v1.9.20/crypto/crypto.go#L248"><code>crypto/crypto.go</code></a></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb12-1"><a href="./#cb12-1"></a><span class="co">// ValidateSignatureValues verifies whether the signature values are valid with</span></span>
<span id="cb12-2"><a href="./#cb12-2"></a><span class="co">// the given chain rules. The v value is assumed to be either 0 or 1.</span></span>
<span id="cb12-3"><a href="./#cb12-3"></a><span class="kw">func</span> ValidateSignatureValues(v <span class="dt">byte</span>, r, s *big.Int, homestead <span class="dt">bool</span>) <span class="dt">bool</span> {</span>
<span id="cb12-4"><a href="./#cb12-4"></a>	<span class="kw">if</span> r.Cmp(common.Big1) &lt; <span class="dv">0</span> || s.Cmp(common.Big1) &lt; <span class="dv">0</span> {</span>
<span id="cb12-5"><a href="./#cb12-5"></a>		<span class="kw">return</span> <span class="ot">false</span></span>
<span id="cb12-6"><a href="./#cb12-6"></a>	}</span>
<span id="cb12-7"><a href="./#cb12-7"></a>	<span class="co">// reject upper range of s values (ECDSA malleability)</span></span>
<span id="cb12-8"><a href="./#cb12-8"></a>	<span class="co">// see discussion in secp256k1/libsecp256k1/include/secp256k1.h</span></span>
<span id="cb12-9"><a href="./#cb12-9"></a>	<span class="kw">if</span> homestead &amp;&amp; s.Cmp(secp256k1halfN) &gt; <span class="dv">0</span> {</span>
<span id="cb12-10"><a href="./#cb12-10"></a>		<span class="kw">return</span> <span class="ot">false</span></span>
<span id="cb12-11"><a href="./#cb12-11"></a>	}</span>
<span id="cb12-12"><a href="./#cb12-12"></a>	<span class="co">// Frontier: allow s to be in full N range</span></span>
<span id="cb12-13"><a href="./#cb12-13"></a>	<span class="kw">return</span> r.Cmp(secp256k1N) &lt; <span class="dv">0</span> &amp;&amp; s.Cmp(secp256k1N) &lt; <span class="dv">0</span> &amp;&amp; (v == <span class="dv">0</span> || v == <span class="dv">1</span>)</span>
<span id="cb12-14"><a href="./#cb12-14"></a>}</span></code></pre></div>
<h2 id="executing-code-in-the-evm"><span class="header-section-number">4.2</span> Executing code in the EVM</h2>
<p>The code in Ethereum contracts is written in a low-level, stack-based bytecode language, referred to as EVM<a href="./#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> code. The code consists of a series of bytes, where each byte represents an <a href="https://ethervm.io/#opcodes">operation</a>. The operations have access to three types of storage:</p>
<ul>
<li>The stack, a last-in-first-out container to which values can be pushed and popped.</li>
<li>Memory, an infinitely expandable byte array.</li>
<li>The contract‚Äôs long-term storage, a key/value store. Unlike stack and memory, which reset after computation ends, storage persists for the long term.</li>
</ul>
<p>If a payload is present but the transaction recipient is left unspecified a new contract is created at an address equal to the hash of the payload and the code is stored in the contract account state. The payload of a transaction creating a contract is itself bytecode that runs the contract constructor, sets up the initial contract state and returns the final contract bytecode, i.e.¬†constructors are not present in the contract once deployed. To invoke a contract the contract account address is specified as the recipient and the transaction payload formatted according to the contract ABI<a href="./#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> is used as input when invoking the contract code. Ether balances in contract accounts are governed by the contract code.</p>
<p>Contracts can interact with other contracts by sending messages to the other contract account address.</p>
<p><a href="https://github.com/ethereum/go-ethereum/blob/v1.9.20/core/vm/opcodes.go#L56"><code>core/vm/opcodes.go</code></a></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb13-1"><a href="./#cb13-1"></a><span class="co">// 0x10 range - comparison ops.</span></span>
<span id="cb13-2"><a href="./#cb13-2"></a><span class="kw">const</span> (</span>
<span id="cb13-3"><a href="./#cb13-3"></a>	LT OpCode = <span class="ot">iota</span> + <span class="dv">0x10</span></span>
<span id="cb13-4"><a href="./#cb13-4"></a>	GT</span>
<span id="cb13-5"><a href="./#cb13-5"></a>	SLT</span>
<span id="cb13-6"><a href="./#cb13-6"></a>	SGT</span>
<span id="cb13-7"><a href="./#cb13-7"></a>	EQ</span>
<span id="cb13-8"><a href="./#cb13-8"></a>	ISZERO</span>
<span id="cb13-9"><a href="./#cb13-9"></a>	AND</span>
<span id="cb13-10"><a href="./#cb13-10"></a>	OR</span>
<span id="cb13-11"><a href="./#cb13-11"></a>	XOR</span>
<span id="cb13-12"><a href="./#cb13-12"></a>	NOT</span>
<span id="cb13-13"><a href="./#cb13-13"></a>	BYTE</span>
<span id="cb13-14"><a href="./#cb13-14"></a>	SHL</span>
<span id="cb13-15"><a href="./#cb13-15"></a>	SHR</span>
<span id="cb13-16"><a href="./#cb13-16"></a>	SAR</span>
<span id="cb13-17"><a href="./#cb13-17"></a></span>
<span id="cb13-18"><a href="./#cb13-18"></a>	SHA3 OpCode = <span class="dv">0x20</span></span>
<span id="cb13-19"><a href="./#cb13-19"></a>)</span></code></pre></div>
<p>The EVM is a Turing-complete runtime environment and as such it can execute all kinds of computations, including infinite loops. As a DDoS prevention executing an operation carries a cost measured in gas. Different operations have different gas costs accessing the contracts long term storage may be much more expensive than adding two integers together<a href="./#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>. Gas is priced in ether, denominated in wei, so the the total cost of a computation is <span class="math inline">\(gas * price_{gas}\)</span>. Revisiting the <code>txdata struct</code> we can now discuss two mandatory fields, the gas price and the gas limit. The gas price is the amount that the originator of the transaction is willing to pay for the gas required to execute the operations in the payload. The gas limit sets an upper bound on the amount of gas the originator of the transaction is willing to pay for.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb14-1"><a href="./#cb14-1"></a>	Price        *big.Int        <span class="st">`json:&quot;gasPrice&quot; gencodec:&quot;required&quot;`</span></span>
<span id="cb14-2"><a href="./#cb14-2"></a>	GasLimit     <span class="dt">uint64</span>          <span class="st">`json:&quot;gas&quot;      gencodec:&quot;required&quot;`</span></span>
<span id="cb14-3"><a href="./#cb14-3"></a>	Payload      []<span class="dt">byte</span>          <span class="st">`json:&quot;input&quot;    gencodec:&quot;required&quot;`</span></span></code></pre></div>
<p><a href="https://github.com/ethereum/go-ethereum/blob/v1.9.20/core/vm/gas_table.go#L250"><code>core/vm/gas_table.go</code></a></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb15-1"><a href="./#cb15-1"></a><span class="kw">func</span> gasSha3(evm *EVM, contract *Contract, stack *Stack, mem *Memory, memorySize <span class="dt">uint64</span>) (<span class="dt">uint64</span>, <span class="dt">error</span>) {</span>
<span id="cb15-2"><a href="./#cb15-2"></a>	gas, err := memoryGasCost(mem, memorySize)</span>
<span id="cb15-3"><a href="./#cb15-3"></a>	<span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb15-4"><a href="./#cb15-4"></a>		<span class="kw">return</span> <span class="dv">0</span>, err</span>
<span id="cb15-5"><a href="./#cb15-5"></a>	}</span>
<span id="cb15-6"><a href="./#cb15-6"></a>	wordGas, overflow := stack.Back(<span class="dv">1</span>).Uint64WithOverflow()</span>
<span id="cb15-7"><a href="./#cb15-7"></a>	<span class="kw">if</span> overflow {</span>
<span id="cb15-8"><a href="./#cb15-8"></a>		<span class="kw">return</span> <span class="dv">0</span>, ErrGasUintOverflow</span>
<span id="cb15-9"><a href="./#cb15-9"></a>	}</span>
<span id="cb15-10"><a href="./#cb15-10"></a>	<span class="kw">if</span> wordGas, overflow = math.SafeMul(toWordSize(wordGas), params.Sha3WordGas); overflow {</span>
<span id="cb15-11"><a href="./#cb15-11"></a>		<span class="kw">return</span> <span class="dv">0</span>, ErrGasUintOverflow</span>
<span id="cb15-12"><a href="./#cb15-12"></a>	}</span>
<span id="cb15-13"><a href="./#cb15-13"></a>	<span class="kw">if</span> gas, overflow = math.SafeAdd(gas, wordGas); overflow {</span>
<span id="cb15-14"><a href="./#cb15-14"></a>		<span class="kw">return</span> <span class="dv">0</span>, ErrGasUintOverflow</span>
<span id="cb15-15"><a href="./#cb15-15"></a>	}</span>
<span id="cb15-16"><a href="./#cb15-16"></a>	<span class="kw">return</span> gas, <span class="ot">nil</span></span>
<span id="cb15-17"><a href="./#cb15-17"></a>}</span></code></pre></div>
<p>When nodes execute the operations in sequence they must constantly compare accumulated gas cost with the gas limit. If the limit is hit, the balance of the originator account is insufficient for further computation, or the code executes an invalid operation, the node rolls the state back to undo all changes the operations in the transaction have done. Even though the computation failed all the nodes already performed computation and therefore gas payments are not rolled back.</p>
<p><a href="https://github.com/ethereum/go-ethereum/blob/v1.9.20/core/vm/interpreter.go#L244"><code>core/vm/interpreter.go</code></a></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb16-1"><a href="./#cb16-1"></a></span>
<span id="cb16-2"><a href="./#cb16-2"></a>		<span class="co">// Static portion of gas</span></span>
<span id="cb16-3"><a href="./#cb16-3"></a>		cost = operation.constantGas <span class="co">// For tracing</span></span>
<span id="cb16-4"><a href="./#cb16-4"></a>		<span class="kw">if</span> !contract.UseGas(operation.constantGas) {</span>
<span id="cb16-5"><a href="./#cb16-5"></a>			<span class="kw">return</span> <span class="ot">nil</span>, ErrOutOfGas</span>
<span id="cb16-6"><a href="./#cb16-6"></a>		}</span></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb17-1"><a href="./#cb17-1"></a>		<span class="co">// Dynamic portion of gas</span></span>
<span id="cb17-2"><a href="./#cb17-2"></a>		<span class="co">// consume the gas and return an error if not enough gas is available.</span></span>
<span id="cb17-3"><a href="./#cb17-3"></a>		<span class="co">// cost is explicitly set so that the capture state defer method can get the proper cost</span></span>
<span id="cb17-4"><a href="./#cb17-4"></a>		<span class="kw">if</span> operation.dynamicGas != <span class="ot">nil</span> {</span>
<span id="cb17-5"><a href="./#cb17-5"></a>			<span class="kw">var</span> dynamicCost <span class="dt">uint64</span></span>
<span id="cb17-6"><a href="./#cb17-6"></a>			dynamicCost, err = operation.dynamicGas(in.evm, contract, stack, mem, memorySize)</span>
<span id="cb17-7"><a href="./#cb17-7"></a>			cost += dynamicCost <span class="co">// total cost, for debug tracing</span></span>
<span id="cb17-8"><a href="./#cb17-8"></a>			<span class="kw">if</span> err != <span class="ot">nil</span> || !contract.UseGas(dynamicCost) {</span>
<span id="cb17-9"><a href="./#cb17-9"></a>				<span class="kw">return</span> <span class="ot">nil</span>, ErrOutOfGas</span>
<span id="cb17-10"><a href="./#cb17-10"></a>			}</span>
<span id="cb17-11"><a href="./#cb17-11"></a>		}</span></code></pre></div>
<p><a href="https://github.com/ethereum/go-ethereum/blob/v1.9.20/core/vm/contract.go#L179"><code>core/vm/contract.go</code></a></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb18-1"><a href="./#cb18-1"></a><span class="co">// UseGas attempts the use gas and subtracts it and returns true on success</span></span>
<span id="cb18-2"><a href="./#cb18-2"></a><span class="kw">func</span> (c *Contract) UseGas(gas <span class="dt">uint64</span>) (ok <span class="dt">bool</span>) {</span>
<span id="cb18-3"><a href="./#cb18-3"></a>	<span class="kw">if</span> c.Gas &lt; gas {</span>
<span id="cb18-4"><a href="./#cb18-4"></a>		<span class="kw">return</span> <span class="ot">false</span></span>
<span id="cb18-5"><a href="./#cb18-5"></a>	}</span>
<span id="cb18-6"><a href="./#cb18-6"></a>	c.Gas -= gas</span>
<span id="cb18-7"><a href="./#cb18-7"></a>	<span class="kw">return</span> <span class="ot">true</span></span>
<span id="cb18-8"><a href="./#cb18-8"></a>}</span></code></pre></div>
<h1 id="transacting-Ô∏è"><span class="header-section-number">5</span> Transacting ‚öôÔ∏è</h1>
<h2 id="broadcasting-transactions"><span class="header-section-number">5.1</span> Broadcasting transactions</h2>
<p>Ethereum uses the <a href="https://cryptobook.nakov.com/digital-signatures/ecdsa-sign-verify-messages">ECDSA signature</a> scheme for the secp256k1 elliptic curve. The <code>crypto</code> module provides two implementations for <code>crypto.Sign</code>, one relying on an <a href="./">elliptic curve cryptography library</a> written in pure Go and the other relying on <a href="https://github.com/bitcoin-core/secp256k1">libsecp256k1</a> written C and called using cgo. ECDSA signatures are returned as a pair of integers <span class="math inline">\((r, s)\)</span>, each in the range <span class="math inline">\([1, 2^{256}-1]\)</span>, where <span class="math inline">\(r\)</span> is the <span class="math inline">\(x\)</span>-coordinate of a random point <span class="math inline">\(R = k * G\)</span> and <span class="math inline">\(s = k^{-1} * (h + r * privKey)\)</span> is a proof that the signer knows message <span class="math inline">\(h = hash(msg)\)</span> and private key <span class="math inline">\(privKey\)</span>. With a signed transaction a node relays it to the peer-to-peer network as described above.</p>
<p>It is important to know that the ECDSA signature scheme allows the public key to be recovered from the signed message together with the signature. The recovery process is based on some mathematical computations and returns 0, 1 or 2 possible points that are valid public keys, corresponding to the signature. To avoid this ambiguity, some ECDSA implementations add one additional bit <span class="math inline">\(v\)</span> to the signature during the signing process and it takes the form <span class="math inline">\((r, s, v)\)</span>. From this extended ECDSA signature and the signed message, the signer‚Äôs public key can be restored with confidence. Ethereum uses the extended signatures for the signed transactions on the chain to save storage and bandwidth.</p>
<p><a href="https://github.com/ethereum/go-ethereum/blob/v1.9.20/core/types/transaction.go#L248"><code>core/types/transaction.go</code></a></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb19-1"><a href="./#cb19-1"></a><span class="co">// WithSignature returns a new transaction with the given signature.</span></span>
<span id="cb19-2"><a href="./#cb19-2"></a><span class="co">// This signature needs to be in the [R || S || V] format where V is 0 or 1.</span></span>
<span id="cb19-3"><a href="./#cb19-3"></a><span class="kw">func</span> (tx *Transaction) WithSignature(signer Signer, sig []<span class="dt">byte</span>) (*Transaction, <span class="dt">error</span>) {</span>
<span id="cb19-4"><a href="./#cb19-4"></a>	r, s, v, err := signer.SignatureValues(tx, sig)</span>
<span id="cb19-5"><a href="./#cb19-5"></a>	<span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb19-6"><a href="./#cb19-6"></a>		<span class="kw">return</span> <span class="ot">nil</span>, err</span>
<span id="cb19-7"><a href="./#cb19-7"></a>	}</span>
<span id="cb19-8"><a href="./#cb19-8"></a>	cpy := &amp;Transaction{</span>
<span id="cb19-9"><a href="./#cb19-9"></a>		data: tx.data,</span>
<span id="cb19-10"><a href="./#cb19-10"></a>		time: tx.time,</span>
<span id="cb19-11"><a href="./#cb19-11"></a>	}</span>
<span id="cb19-12"><a href="./#cb19-12"></a>	cpy.data.R, cpy.data.S, cpy.data.V = r, s, v</span>
<span id="cb19-13"><a href="./#cb19-13"></a>	<span class="kw">return</span> cpy, <span class="ot">nil</span></span>
<span id="cb19-14"><a href="./#cb19-14"></a>}</span></code></pre></div>
<p><a href="https://github.com/ethereum/go-ethereum/blob/v1.9.20/core/types/transaction_signing.go#L55"><code>core/types/transaction_signing.go</code></a></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb20-1"><a href="./#cb20-1"></a><span class="co">// SignTx signs the transaction using the given signer and private key</span></span>
<span id="cb20-2"><a href="./#cb20-2"></a><span class="kw">func</span> SignTx(tx *Transaction, s Signer, prv *ecdsa.PrivateKey) (*Transaction, <span class="dt">error</span>) {</span>
<span id="cb20-3"><a href="./#cb20-3"></a>	h := s.Hash(tx)</span>
<span id="cb20-4"><a href="./#cb20-4"></a>	sig, err := crypto.Sign(h[:], prv)</span>
<span id="cb20-5"><a href="./#cb20-5"></a>	<span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb20-6"><a href="./#cb20-6"></a>		<span class="kw">return</span> <span class="ot">nil</span>, err</span>
<span id="cb20-7"><a href="./#cb20-7"></a>	}</span>
<span id="cb20-8"><a href="./#cb20-8"></a>	<span class="kw">return</span> tx.WithSignature(s, sig)</span>
<span id="cb20-9"><a href="./#cb20-9"></a>}</span>
<span id="cb20-10"><a href="./#cb20-10"></a></span>
<span id="cb20-11"><a href="./#cb20-11"></a><span class="co">// SignatureValues returns signature values. This signature</span></span>
<span id="cb20-12"><a href="./#cb20-12"></a><span class="co">// needs to be in the [R || S || V] format where V is 0 or 1.</span></span>
<span id="cb20-13"><a href="./#cb20-13"></a><span class="kw">func</span> (s EIP155Signer) SignatureValues(tx *Transaction, sig []<span class="dt">byte</span>) (R, S, V *big.Int, err <span class="dt">error</span>) {</span>
<span id="cb20-14"><a href="./#cb20-14"></a>	R, S, V, err = HomesteadSigner{}.SignatureValues(tx, sig)</span>
<span id="cb20-15"><a href="./#cb20-15"></a>	<span class="kw">if</span> err != <span class="ot">nil</span> {</span>
<span id="cb20-16"><a href="./#cb20-16"></a>		<span class="kw">return</span> <span class="ot">nil</span>, <span class="ot">nil</span>, <span class="ot">nil</span>, err</span>
<span id="cb20-17"><a href="./#cb20-17"></a>	}</span>
<span id="cb20-18"><a href="./#cb20-18"></a>	<span class="kw">if</span> s.chainId.Sign() != <span class="dv">0</span> {</span>
<span id="cb20-19"><a href="./#cb20-19"></a>		V = big.NewInt(<span class="dt">int64</span>(sig[<span class="dv">64</span>] + <span class="dv">35</span>))</span>
<span id="cb20-20"><a href="./#cb20-20"></a>		V.Add(V, s.chainIdMul)</span>
<span id="cb20-21"><a href="./#cb20-21"></a>	}</span>
<span id="cb20-22"><a href="./#cb20-22"></a>	<span class="kw">return</span> R, S, V, <span class="ot">nil</span></span>
<span id="cb20-23"><a href="./#cb20-23"></a>}</span>
<span id="cb20-24"><a href="./#cb20-24"></a></span>
<span id="cb20-25"><a href="./#cb20-25"></a><span class="co">// HomesteadTransaction implements TransactionInterface using the</span></span>
<span id="cb20-26"><a href="./#cb20-26"></a><span class="co">// homestead rules.</span></span>
<span id="cb20-27"><a href="./#cb20-27"></a><span class="kw">type</span> HomesteadSigner <span class="kw">struct</span>{ FrontierSigner }</span>
<span id="cb20-28"><a href="./#cb20-28"></a></span>
<span id="cb20-29"><a href="./#cb20-29"></a><span class="co">// SignatureValues returns signature values. This signature</span></span>
<span id="cb20-30"><a href="./#cb20-30"></a><span class="co">// needs to be in the [R || S || V] format where V is 0 or 1.</span></span>
<span id="cb20-31"><a href="./#cb20-31"></a><span class="kw">func</span> (hs HomesteadSigner) SignatureValues(tx *Transaction, sig []<span class="dt">byte</span>) (r, s, v *big.Int, err <span class="dt">error</span>) {</span>
<span id="cb20-32"><a href="./#cb20-32"></a>	<span class="kw">return</span> hs.FrontierSigner.SignatureValues(tx, sig)</span>
<span id="cb20-33"><a href="./#cb20-33"></a>}</span>
<span id="cb20-34"><a href="./#cb20-34"></a></span>
<span id="cb20-35"><a href="./#cb20-35"></a><span class="kw">type</span> FrontierSigner <span class="kw">struct</span>{}</span>
<span id="cb20-36"><a href="./#cb20-36"></a></span>
<span id="cb20-37"><a href="./#cb20-37"></a><span class="co">// SignatureValues returns signature values. This signature</span></span>
<span id="cb20-38"><a href="./#cb20-38"></a><span class="co">// needs to be in the [R || S || V] format where V is 0 or 1.</span></span>
<span id="cb20-39"><a href="./#cb20-39"></a><span class="kw">func</span> (fs FrontierSigner) SignatureValues(tx *Transaction, sig []<span class="dt">byte</span>) (r, s, v *big.Int, err <span class="dt">error</span>) {</span>
<span id="cb20-40"><a href="./#cb20-40"></a>	<span class="kw">if</span> <span class="bu">len</span>(sig) != crypto.SignatureLength {</span>
<span id="cb20-41"><a href="./#cb20-41"></a>		<span class="bu">panic</span>(fmt.Sprintf(<span class="st">&quot;wrong size for signature: got %d, want %d&quot;</span>, <span class="bu">len</span>(sig), crypto.SignatureLength))</span>
<span id="cb20-42"><a href="./#cb20-42"></a>	}</span>
<span id="cb20-43"><a href="./#cb20-43"></a>	r = <span class="bu">new</span>(big.Int).SetBytes(sig[:<span class="dv">32</span>])</span>
<span id="cb20-44"><a href="./#cb20-44"></a>	s = <span class="bu">new</span>(big.Int).SetBytes(sig[<span class="dv">32</span>:<span class="dv">64</span>])</span>
<span id="cb20-45"><a href="./#cb20-45"></a>	v = <span class="bu">new</span>(big.Int).SetBytes([]<span class="dt">byte</span>{sig[<span class="dv">64</span>] + <span class="dv">27</span>})</span>
<span id="cb20-46"><a href="./#cb20-46"></a>	<span class="kw">return</span> r, s, v, <span class="ot">nil</span></span>
<span id="cb20-47"><a href="./#cb20-47"></a>}</span></code></pre></div>
<h2 id="mining-transactions-into-a-block"><span class="header-section-number">5.2</span> Mining transactions into a block ‚õè</h2>
<p>If nodes in the peer-to-peer network, located in different parts of the world, would simply update the state based on the transactions in the order they discover them, different nodes would derive different states because there is no guaranteed order in which transactions arrive to nodes. To solve this problem, there needs to be a consensus protocol for the nodes to order them in a canonical order. The consensus protocol for the Ethereum mainnet includes a proof-of-work algorithm called Ethash. The protocol relies on computing the difficulty for blocks, <span class="math inline">\(H_d\)</span>, which is computed from the previous block‚Äôs difficulty, the current timestamp and includes a time bomb-factor üß®. The purpose of the difficulty is twofold; adjust the time it takes to mine a block to the 15 second target and to determine the canonical blockchain in case of forks. The difficulty is included in blocks so that once they are mined in to the blockchain history it is easy to compute both the previous block‚Äôs difficulty and the total difficulty as the sum of all previous blocks‚Äô difficulty.</p>
<p><a href="https://github.com/ethereum/go-ethereum/blob/v1.9.20/core/types/block.go#L80"><code>core/types/block.go</code></a></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb21-1"><a href="./#cb21-1"></a>	Difficulty  *big.Int       <span class="st">`json:&quot;difficulty&quot;       gencodec:&quot;required&quot;`</span></span></code></pre></div>
<p>Ethash repeatedly computes the <span class="math inline">\(PoW\)</span> function, incrementing the nonce each time, until the nonce, <span class="math inline">\(H_n\)</span>, satisfy the relations:</p>
<p><span class="math display">\[ n \leq \frac{2_{256}}{H_d} \; ‚àß \; m = H_m \]</span></p>
<p>with <span class="math inline">\((n, m) = PoW(H_{\hat{n}}, H_n, d)\)</span> and <span class="math inline">\(H_m\)</span> the header‚Äôs mix-hash. Where <span class="math inline">\(H_{\hat{n}}\)</span> is the new block‚Äôs header <span class="math inline">\(H\)</span>, but without the nonce and mix-hash components, <span class="math inline">\(d\)</span> being the current DAG, a large data set needed to compute the mix-hash, and <span class="math inline">\(PoW\)</span> is the proof-of-work function: this evaluates to an array with the first item being the mix-hash, to prove that a correct DAG has been used, and the second item being a pseudo-random number cryptographically dependent on <span class="math inline">\(H\)</span> and <span class="math inline">\(d\)</span>. Given an approximately uniform distribution in the range <span class="math inline">\([0, 2^{64})\)</span>, the expected time to find a solution is proportional to the difficulty, <span class="math inline">\(H_d\)</span>.</p>
<p>The difficulty time bomb refers to a component of the block difficulty, <span class="math inline">\(H_d\)</span>, which grows exponentially over time making it impossible to mine. That future period is commonly referred to as the ice-age. The purpose of the time bomb is to signal the intent to change Ethereum from a proof-of-work to a proof-of-stake based consensus algorithm. This approach encourages the network to transition to <a href="https://ethereum.org/en/eth2/">Ethereum 2.0</a> and staking faster or face the consequences of slower block times. The time bomb has been delayed three times with hard forks; Byzantium upgrade in October 2017, Constantinople in February 2019, and Muir Glacier in January 2020 which delayed the difficulty bomb for another 4,000,000 blocks giving the community until roughly July 2021 to launch Ethereum 2.0‚Äôs <a href="https://medium.com/@ralexstokes/the-finality-gadget-2bf608529e50">finality gadget</a> or delay again before the ice-age begins to slow block times to over 20 seconds.</p>
<p><a href="https://github.com/ethereum/go-ethereum/blob/v1.9.20/consensus/ethash/consensus.go#L48"><code>consensus/ethash/consensus.go</code></a></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb22-1"><a href="./#cb22-1"></a>	<span class="co">// calcDifficultyEip2384 is the difficulty adjustment algorithm as specified by EIP 2384.</span></span>
<span id="cb22-2"><a href="./#cb22-2"></a>	<span class="co">// It offsets the bomb 4M blocks from Constantinople, so in total 9M blocks.</span></span>
<span id="cb22-3"><a href="./#cb22-3"></a>	<span class="co">// Specification EIP-2384: https://eips.ethereum.org/EIPS/eip-2384</span></span>
<span id="cb22-4"><a href="./#cb22-4"></a>	calcDifficultyEip2384 = makeDifficultyCalculator(big.NewInt(<span class="dv">9000000</span>))</span>
<span id="cb22-5"><a href="./#cb22-5"></a></span>
<span id="cb22-6"><a href="./#cb22-6"></a><span class="co">// CalcDifficulty is the difficulty adjustment algorithm. It returns</span></span>
<span id="cb22-7"><a href="./#cb22-7"></a><span class="co">// the difficulty that a new block should have when created at time</span></span>
<span id="cb22-8"><a href="./#cb22-8"></a><span class="co">// given the parent block's time and difficulty.</span></span>
<span id="cb22-9"><a href="./#cb22-9"></a><span class="kw">func</span> CalcDifficulty(config *params.ChainConfig, time <span class="dt">uint64</span>, parent *types.Header) *big.Int {</span>
<span id="cb22-10"><a href="./#cb22-10"></a>	next := <span class="bu">new</span>(big.Int).Add(parent.Number, big1)</span>
<span id="cb22-11"><a href="./#cb22-11"></a>	<span class="kw">switch</span> {</span>
<span id="cb22-12"><a href="./#cb22-12"></a>	<span class="kw">case</span> config.IsMuirGlacier(next):</span>
<span id="cb22-13"><a href="./#cb22-13"></a>		<span class="kw">return</span> calcDifficultyEip2384(time, parent)</span>
<span id="cb22-14"><a href="./#cb22-14"></a>	<span class="kw">case</span> config.IsConstantinople(next):</span>
<span id="cb22-15"><a href="./#cb22-15"></a>		<span class="kw">return</span> calcDifficultyConstantinople(time, parent)</span>
<span id="cb22-16"><a href="./#cb22-16"></a>	<span class="kw">case</span> config.IsByzantium(next):</span>
<span id="cb22-17"><a href="./#cb22-17"></a>		<span class="kw">return</span> calcDifficultyByzantium(time, parent)</span>
<span id="cb22-18"><a href="./#cb22-18"></a>	<span class="kw">case</span> config.IsHomestead(next):</span>
<span id="cb22-19"><a href="./#cb22-19"></a>		<span class="kw">return</span> calcDifficultyHomestead(time, parent)</span>
<span id="cb22-20"><a href="./#cb22-20"></a>	<span class="kw">default</span>:</span>
<span id="cb22-21"><a href="./#cb22-21"></a>		<span class="kw">return</span> calcDifficultyFrontier(time, parent)</span>
<span id="cb22-22"><a href="./#cb22-22"></a>	}</span>
<span id="cb22-23"><a href="./#cb22-23"></a>}</span>
<span id="cb22-24"><a href="./#cb22-24"></a></span>
<span id="cb22-25"><a href="./#cb22-25"></a><span class="co">// makeDifficultyCalculator creates a difficultyCalculator with the given bomb-delay.</span></span>
<span id="cb22-26"><a href="./#cb22-26"></a><span class="co">// the difficulty is calculated with Byzantium rules, which differs from Homestead in</span></span>
<span id="cb22-27"><a href="./#cb22-27"></a><span class="co">// how uncles affect the calculation</span></span>
<span id="cb22-28"><a href="./#cb22-28"></a><span class="kw">func</span> makeDifficultyCalculator(bombDelay *big.Int) <span class="kw">func</span>(time <span class="dt">uint64</span>, parent *types.Header) *big.Int {</span>
<span id="cb22-29"><a href="./#cb22-29"></a>	<span class="co">// Note, the calculations below looks at the parent number, which is 1 below</span></span>
<span id="cb22-30"><a href="./#cb22-30"></a>	<span class="co">// the block number. Thus we remove one from the delay given</span></span>
<span id="cb22-31"><a href="./#cb22-31"></a>	bombDelayFromParent := <span class="bu">new</span>(big.Int).Sub(bombDelay, big1)</span>
<span id="cb22-32"><a href="./#cb22-32"></a>	<span class="kw">return</span> <span class="kw">func</span>(time <span class="dt">uint64</span>, parent *types.Header) *big.Int {</span>
<span id="cb22-33"><a href="./#cb22-33"></a>		<span class="co">// https://github.com/ethereum/EIPs/issues/100.</span></span>
<span id="cb22-34"><a href="./#cb22-34"></a>		<span class="co">// algorithm:</span></span>
<span id="cb22-35"><a href="./#cb22-35"></a>		<span class="co">// diff = (parent_diff +</span></span>
<span id="cb22-36"><a href="./#cb22-36"></a>		<span class="co">//         (parent_diff / 2048 * max((2 if len(parent.uncles) else 1) - ((timestamp - parent.timestamp) // 9), -99))</span></span>
<span id="cb22-37"><a href="./#cb22-37"></a>		<span class="co">//        ) + 2^(periodCount - 2)</span></span>
<span id="cb22-38"><a href="./#cb22-38"></a></span>
<span id="cb22-39"><a href="./#cb22-39"></a>		bigTime := <span class="bu">new</span>(big.Int).SetUint64(time)</span>
<span id="cb22-40"><a href="./#cb22-40"></a>		bigParentTime := <span class="bu">new</span>(big.Int).SetUint64(parent.Time)</span>
<span id="cb22-41"><a href="./#cb22-41"></a></span>
<span id="cb22-42"><a href="./#cb22-42"></a>		<span class="co">// holds intermediate values to make the algo easier to read &amp; audit</span></span>
<span id="cb22-43"><a href="./#cb22-43"></a>		x := <span class="bu">new</span>(big.Int)</span>
<span id="cb22-44"><a href="./#cb22-44"></a>		y := <span class="bu">new</span>(big.Int)</span>
<span id="cb22-45"><a href="./#cb22-45"></a></span>
<span id="cb22-46"><a href="./#cb22-46"></a>		<span class="co">// (2 if len(parent_uncles) else 1) - (block_timestamp - parent_timestamp) // 9</span></span>
<span id="cb22-47"><a href="./#cb22-47"></a>		x.Sub(bigTime, bigParentTime)</span>
<span id="cb22-48"><a href="./#cb22-48"></a>		x.Div(x, big9)</span>
<span id="cb22-49"><a href="./#cb22-49"></a>		<span class="kw">if</span> parent.UncleHash == types.EmptyUncleHash {</span>
<span id="cb22-50"><a href="./#cb22-50"></a>			x.Sub(big1, x)</span>
<span id="cb22-51"><a href="./#cb22-51"></a>		} <span class="kw">else</span> {</span>
<span id="cb22-52"><a href="./#cb22-52"></a>			x.Sub(big2, x)</span>
<span id="cb22-53"><a href="./#cb22-53"></a>		}</span>
<span id="cb22-54"><a href="./#cb22-54"></a>		<span class="co">// max((2 if len(parent_uncles) else 1) - (block_timestamp - parent_timestamp) // 9, -99)</span></span>
<span id="cb22-55"><a href="./#cb22-55"></a>		<span class="kw">if</span> x.Cmp(bigMinus99) &lt; <span class="dv">0</span> {</span>
<span id="cb22-56"><a href="./#cb22-56"></a>			x.Set(bigMinus99)</span>
<span id="cb22-57"><a href="./#cb22-57"></a>		}</span>
<span id="cb22-58"><a href="./#cb22-58"></a>		<span class="co">// parent_diff + (parent_diff / 2048 * max((2 if len(parent.uncles) else 1) - ((timestamp - parent.timestamp) // 9), -99))</span></span>
<span id="cb22-59"><a href="./#cb22-59"></a>		y.Div(parent.Difficulty, params.DifficultyBoundDivisor)</span>
<span id="cb22-60"><a href="./#cb22-60"></a>		x.Mul(y, x)</span>
<span id="cb22-61"><a href="./#cb22-61"></a>		x.Add(parent.Difficulty, x)</span>
<span id="cb22-62"><a href="./#cb22-62"></a></span>
<span id="cb22-63"><a href="./#cb22-63"></a>		<span class="co">// minimum difficulty can ever be (before exponential factor)</span></span>
<span id="cb22-64"><a href="./#cb22-64"></a>		<span class="kw">if</span> x.Cmp(params.MinimumDifficulty) &lt; <span class="dv">0</span> {</span>
<span id="cb22-65"><a href="./#cb22-65"></a>			x.Set(params.MinimumDifficulty)</span>
<span id="cb22-66"><a href="./#cb22-66"></a>		}</span>
<span id="cb22-67"><a href="./#cb22-67"></a>		<span class="co">// calculate a fake block number for the ice-age delay</span></span>
<span id="cb22-68"><a href="./#cb22-68"></a>		<span class="co">// Specification: https://eips.ethereum.org/EIPS/eip-1234</span></span>
<span id="cb22-69"><a href="./#cb22-69"></a>		fakeBlockNumber := <span class="bu">new</span>(big.Int)</span>
<span id="cb22-70"><a href="./#cb22-70"></a>		<span class="kw">if</span> parent.Number.Cmp(bombDelayFromParent) &gt;= <span class="dv">0</span> {</span>
<span id="cb22-71"><a href="./#cb22-71"></a>			fakeBlockNumber = fakeBlockNumber.Sub(parent.Number, bombDelayFromParent)</span>
<span id="cb22-72"><a href="./#cb22-72"></a>		}</span>
<span id="cb22-73"><a href="./#cb22-73"></a>		<span class="co">// for the exponential factor</span></span>
<span id="cb22-74"><a href="./#cb22-74"></a>		periodCount := fakeBlockNumber</span>
<span id="cb22-75"><a href="./#cb22-75"></a>		periodCount.Div(periodCount, expDiffPeriod)</span>
<span id="cb22-76"><a href="./#cb22-76"></a></span>
<span id="cb22-77"><a href="./#cb22-77"></a>		<span class="co">// the exponential factor, commonly referred to as &quot;the bomb&quot;</span></span>
<span id="cb22-78"><a href="./#cb22-78"></a>		<span class="co">// diff = diff + 2^(periodCount - 2)</span></span>
<span id="cb22-79"><a href="./#cb22-79"></a>		<span class="kw">if</span> periodCount.Cmp(big1) &gt; <span class="dv">0</span> {</span>
<span id="cb22-80"><a href="./#cb22-80"></a>			y.Sub(periodCount, big2)</span>
<span id="cb22-81"><a href="./#cb22-81"></a>			y.Exp(big2, y, <span class="ot">nil</span>)</span>
<span id="cb22-82"><a href="./#cb22-82"></a>			x.Add(x, y)</span>
<span id="cb22-83"><a href="./#cb22-83"></a>		}</span>
<span id="cb22-84"><a href="./#cb22-84"></a>		<span class="kw">return</span> x</span>
<span id="cb22-85"><a href="./#cb22-85"></a>	}</span>
<span id="cb22-86"><a href="./#cb22-86"></a>}</span></code></pre></div>
<p>This concludes my journey into Ethereum and its Go implementation. There are a number of other interesting aspects which unfortunately I couldn‚Äôt cover but I encourage you to take the leap and dive right into the belly of the beastüßü .</p>
<p><span class="handwritten">Gisli</span></p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Today there exist Ethereum implementations in C++, Go, Python, Java, Ruby, JavaScript, Haskell and .NET.<a href="./#fnref1" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn2" role="doc-endnote"><p>The lowest unit is a wei. Other denominations include szabo (<span class="math inline">\(10^{12}\)</span> wei), finney (<span class="math inline">\(10^{15}\)</span> wei), and ether (<span class="math inline">\(10^{18}\)</span> wei).<a href="./#fnref2" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn3" role="doc-endnote"><p>A list of <a href="https://chainid.network/">EVM networks</a>.<a href="./#fnref3" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn4" role="doc-endnote"><p>By default the maximum number of connected peers is 50.<a href="./#fnref4" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn5" role="doc-endnote"><p><a href="https://eth.wiki/en/fundamentals/patricia-tree">Merkle Patricia</a> tries provide a fully deterministic, cryptographically authenticated data structure that can be used to store all (key, value) bindings.<a href="./#fnref5" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn6" role="doc-endnote"><p><a href="https://eth.wiki/concepts/evm/evm">Ethereum Virtual Machine</a> (EVM) is a Turing complete virtual machine for Ethereum smart contracts.<a href="./#fnref6" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn7" role="doc-endnote"><p>The Contract <a href="https://solidity.readthedocs.io/en/develop/abi-spec.html">Application Binary Interface</a> (ABI) is the standard way to interact with contracts in the Ethereum ecosystem, both from outside the blockchain and for contract-to-contract interaction.<a href="./#fnref7" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn8" role="doc-endnote"><p><a href="https://docs.google.com/spreadsheets/d/1n6mRqkBz3iWcOlRem_mO09GtSKEKrAsfO7Frgx18pNU/edit#gid=0">Gas Costs from Yellow Paper ‚Äì EIP-150 Revision</a><a href="./#fnref8" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
</ol>
</section>
    </section>

    <section>
        <p>
            @<a href="../../../code/">code</a> 
            #<a href="../../../tags/ethereum/">ethereum</a> 
        </p>
        <p>
        </p>
    </section>

    <footer>
        <nav class="c-pagination p-pagination">
            <div class="c-pagination__ctrl">
                <div class="c-pagination__newer">
                    
                </div>
                <div class="c-pagination__older">
                    <a href="../../../2020/08/a-bref-history-of-ethereum/">Older</a>
                    
                </div>
            </div>
        </nav>
    </footer>

</article>

        </main>
     
        <footer class="l-footer">
            <p class="p-copyright">
                Copyright <i class="fas fa-heart" style="color: red;"></i> G√≠sli Kristj√°nsson 2020
            </p>
        </footer>

        <link rel="stylesheet" href="../../../katex/katex.min.css">
        <script defer src="../../../katex/katex.min.js"></script>
        <script type="text/javascript" script defer src="../../../katex/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
    </body>
</html>
            
